#!/bin/bash
# Copyright (c) 2016 Daniel Gomez <d.gomez@donders.ru.nl>

# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# FSLX is a *dumb* wrapper around some of fsltools.
# It exists so I don't have to remember the arbitrary names of fsl tools,
# nor the inconsistent parameter naming conventions of each of them.
# It also accepts multiple images as input to perform the same operations,
# so one can do something like:
# ls | xargs fslx nan
# And remove nans of all images in a particular directory, for example.
# TODO: Support for applyxfm, registration to MNI, concatenate transformation matrices.
# TODO: Read from STDIN?
# TODO: FAST segmentation
# TODO: Add support for dual_regression
# TODO: Add support for mixture modelling.

function echo_help {
    echo "Welcome to fslx v0.1!! The *dumbest* wrapper of all times."
    echo "Fslx requires an operation and one or more inputs:"
    echo "Compute mean image: fslx mean img1 img2"
    echo ""
    echo "Currently supported operations: moco|mc tmean tstd tsnr abs recip bin nan sin exp rmskull"
    echo "Thresholding lowthresh and highthresh. Syntax: fslx lowthresh number img1 img2"
    echo "Filtering operations: smooth number,  highpass number,  lowpass number"
    echo "Query operations (not pipeable): nvols info header|hd (stats not implemented yet)."
    echo "Temporal split and merge operations (not pipeable currently): split merge"
    echo "Linear registration:"
    echo "fslx align reference img1 img2"
    echo ""
    echo "Melodic ICA: fslx ica img1 img2"
    echo "Because it accepts multiple images, you can do cool stuff like for example:"
    echo "ls | xargs fslx moco | xargs fslx tsnr | xargs fslx nan > list_of_processed_files.txt"
    echo "And get the tsnr (nans converted to 0s ) for all your motion corrected files - and a list of them."
    echo "Oh, and before I forget:"
    echo "Viewer operations: view or v (pipes inputs through)"
    echo ""
    echo "That is the reason why I love nipype. Not."
    echo ""
    echo "Disclaimer: use at your own risk."
    echo ""
    echo "Written by Daniel Gomez"
}

if (($# < 1))
then
    echo_help
    exit 0
fi

# The operation to perform is ALWAYS the first argument to our wrapper.
operation=$1

# We define an array called inputs, which contains all files to process.
# We also define filenames, which are the inputs without file extensions.


# The second input may well be a number, in which case we have to check for it.
re='^[0-9]+([.][0-9]+)?$'
if [[ $2 =~ $re ]] ; then
    inputs[0]=`echo $2`
    filenames[0]=`echo $2`
else
    inputs[0]=`readlink -f $2`
    currfile=${inputs[0]}

    ## Split between directory and basename
    basedir=`readlink -f $(dirname $currfile)`
    basefile=`basename $currfile`

    inputssansextension[0]="$basedir/${basefile%%.*}"
fi


# Start at 2 means: skip $0, $1 (the operation) and $2 (a possible number)
for (( i=3 ; i<=$# ; i++ )) ; do
    currfile=`echo ${!i}`
    currfile=`readlink -f $currfile` # This adds support for relative input paths.

    ## Split between directory and basename
    basedir=`readlink -f $(dirname $currfile)`
    basefile=`basename $currfile`

    inputs[$i-2]=$basedir/$basefile
    inputssansextension[$i-2]="$basedir/${basefile%%.*}"
done

#echo "You choose operation $operation"
#echo "The operation will be applied in "
#echo ${inputssansextension[@]}

# I am aware that there is lots of code repetition and that I could easily refactor the following switch, so:
# TODO: Eliminate obscene amount of repetition.
INDEX_AT=0
for f in ${inputs[@]}
do
    # We need the name without extension to add a suffix according to the operation performed.
    namesansextension=${inputssansextension[$INDEX_AT]}

    case $operation in
        tmean|Tmean)
            # Compute the temporal mean of the image in time. Reduces a 4D to a 3D volume.
            outname=${namesansextension}_tmean.nii.gz
            fslmaths $f -Tmean $outname; echo $outname
            ;;
        tstd|Tstd)
            # Compute the standard deviation of the image in time. Reduces a 4D to a 3D volume.
            outname=${namesansextension}_tmean.nii.gz
            fslmaths $f -Tstd $outname; echo $outname
            ;;
        tsnr)
            # Compute the ratio of the mean and standard deviation of the image (in time). Reduces a 4D to a 3D volume.
            fslmaths $f -Tmean ${namesansextension}_mean_deleteme.nii.gz
            fslmaths $f -Tstd ${namesansextension}_std_deleteme.nii.gz
            fslmaths ${namesansextension}_mean_deleteme.nii.gz -div ${namesansextension}_std_deleteme.nii.gz ${namesansextension}_tsnr.nii.gz
            imrm ${namesansextension}_mean_deleteme.nii.gz ${namesansextension}_std_deleteme.nii.gz
            echo ${namesansextension}_tsnr.nii.gz
            ;;
        mocome|mocomultiecho|memoco)
            # How many volumes?
            numvols=`fslnvols $f`
            # Moco the very first input and output the matrices
            mcflirt -in $f -mats
            echo ${namesansextension}_mcf.nii.gz
            # This will generate a folder called
            matsfolder=${namesansextension}_mcf.mat
            # Now we need to loop over the remaining files, as usual.
            for (( j=1; j<${#inputs[@]}; j++ )) ; do
                fslsplit ${inputs[j]} ${inputssansextension[$j]}_mcf_deleteme -t
                # And loop over the split files, mocoing each of them
                for (( k=0; k<numvols; k++ )) ; do
                    mcflirt -in `echo $(printf "${inputssansextension[$j]}_mcf_deleteme%04d.nii.gz " $k)` -init `echo $(printf "${matsfolder}/MAT_%04d " $k)`
                done
                # Merge into meaninful mocoed file
                fslmerge -t ${inputssansextension[$j]}_mcf.nii.gz `echo $(ls ${inputssansextension[$j]}_mcf_deleteme*_mcf.nii.gz)`
                # Cleanup - no need to  worry about ls directory because inputssansextension contains the whole path.
                imrm `echo $(ls ${inputssansextension[$j]}_mcf_deleteme*.nii.gz)`
                # Pipe name of processed file down the line.
                echo ${inputssansextension[$j]}_mcf.nii.gz
            done
            # Final cleanup
            /usr/bin/rm -rf $matsfolder
            break;
            ;;
        echocombine|combineechoes|combinechoes|catechoes|catme|mecombine|mecat|combinemultiecho|combineme)
            # Merge all echoes by simple addition
            # Number of echoes =
            nechoes=${#inputs[@]}
            x=$f
            tmpname=${inputssansextension[0]}_tmp_deleteme.nii.gz
            outname=${inputssansextension[0]}_echoescombined.nii.gz
            for (( j=1; j<${#inputs[@]}; j++ )) ; do
                # Add an input and overwrite tmpname
                fslmaths $x -add ${inputs[j]} $tmpname > /dev/null
                x=$tmpname
            done
            # Divide ny the total number of echoes
            fslmaths $tmpname -div $nechoes $tmpname
            immv $tmpname $outname
            echo $outname
            break # Break out of the loop, since we looped here.
            ;;
        exp)
            # Compute e**image, voxelwise.
            fslmaths $f -exp ${namesansextension}_exp.nii.gz
            echo ${namesansextension}_exp.nii.gz
            ;;
        lthresh|lthr|lowthresh)
            # Compute lower threshold
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_lthresh${f/./_}.nii.gz
                fslmaths ${inputs[j]} -thr $f $outname > /dev/null
                echo $outname
            done
            break
            ;;
        uthresh|uthr|hthresh|hthr|highthresh)
            # Compute e**image, voxelwise.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_uthresh${f/./_}.nii.gz
                fslmaths ${inputs[j]} -uthr $f $outname > /dev/null
                echo $outname
            done
            break
            ;;
        sin)
            # Compute sin(image), voxelwise.
            fslmaths $f -sin ${namesansextension}_sin.nii.gz
            echo ${namesansextension}_sin.nii.gz
            ;;
        abs|mag|magn)
            # Compute the absolute value of an image, pixelwise.
            fslmaths $f -abs ${namesansextension}_abs.nii.gz
            echo ${namesansextension}_abs.nii.gz
            ;;
        min|minimum|tmin)
            # Compute the absolute value of an image, pixelwise.
            fslmaths $f -Tmin ${namesansextension}_min.nii.gz
            echo ${namesansextension}_min.nii.gz
            ;;
        bin)
            # Create a binary image from the input. Values > 0 are set to 1.
            fslmaths $f -bin ${namesansextension}_bin.nii.gz
            echo ${namesansextension}_bin.nii.gz
            ;;
        nan|nans)
            # Remove nans.
            fslmaths $f -nan ${namesansextension}_no_nans.nii.gz
            echo ${namesansextension}_no_nans.nii.gz
            ;;
        recip)
            # Compute 1/image, voxelwise.
            fslmaths $f -recip ${namesansextension}_recip.nii.gz
            echo ${namesansextension}_recip.nii.gz
            ;;
        percentile|nthpercentile)
            #  Get a brain extracted mask from a given threshold f.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                fslstats -p $f ${inputs[$j]}
            done
            break
            ;;
        moco|mc)
            # Motion correction.
            mcflirt -in $f -out ${namesansextension}_mcf.nii.gz
            echo ${namesansextension}_mcf.nii.gz
            ;;
        header|hd)
            # Read the header.
            fslhd $f
            ;;
        bet|brain|rmskull)
            # Remove the skull from (ideally) an anatomical image.
            bet2 -in $f -out ${namesansextension}_noskull.nii.gz
            echo ${namesansextension}_noskull.nii.gz
            ;;
        betmask|betm|betfracmask)
            #  Get a brain extracted mask from a given threshold f.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_bet${f/./_}
                bet2 ${inputs[$j]} $outname -f $f -n -m
                echo ${outname}_mask.nii.gz
            done
            break
            ;;
        applymask|mask)
            #  Apply a mask on all inputs.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                f_basename=`basename ${f}`
                outname=${inputssansextension[$j]}_maskedwith_${f_basename%%.*}.nii.gz
                fslmaths ${inputs[$j]} -mas $f $outname > /dev/null
                echo $outname
            done
            break
            ;;
        split|tsplit)
            # Split a 4d dataset into multiple 3d.
            fslsplit $f $f -t
            ;;
        merge|tmerge)
            # Merge multiple 2d into a 3d, or multiple 3d into a 4d dataset.
            fslmerge -a ${inputssansextension[0]}_upto_${inputssansextension[-1]}_merged.nii.gz `echo ${inputssansextension[@]}`
            echo ${inputssansextension[0]}_upto_${inputssansextension[-1]}_merged.nii.gz
            break
            ;;
        nvols)
            # Returns the number of volumes in a 4D image.
            fslnvols $f
            ;;
        info)
            # Short info read from the header (datatype and dimensions).
            fslinfo $f
            ;;
        align|register|reg)
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_reg_to_$f.nii.gz
                flirt -in ${inputs[j]} -ref $f -out $outname > /dev/null
                echo $outname
            done
            break
            ;;
        bandpass|bandfilter|bfilter|bfilt)
            # Apply bandpass temporal filter
            ;;
        lowpass|lowfilter|lfilter|lfilt)
            #  Apply lowpass temporal filter.
            # Apply highpass temporal filter with cutoff from 2nd input.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_lowpass${f/./_}.nii.gz
                fslmaths ${inputs[$j]} -bptf -1 $f $outname > /dev/null
                echo $outname
            done
            break
            ;;
        highpass|highfilter|hfilter|hfilt|hpass)
            # Apply highpass temporal filter with cutoff from 2nd input.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_highpass${f/./_}.nii.gz
                fslmaths ${inputs[$j]} -bptf $f -1 $outname > /dev/null
                echo $outname
            done
            break
            ;;
        smooth|sm|gauss)
            # Smooth with a kernel of 2mm.
            for (( j=1 ; j<${#inputs[@]}; j++ )) ; do
                outname=${inputssansextension[$j]}_smooth${f/./_}.nii.gz
                fslmaths ${inputs[$j]} -s $f $outname > /dev/null
                echo $outname
            done
            break
            ;;
        groupica)
            echo "Operation not implemented yet."
            break
            ;;
        melodic|ica|pica)
            melodic -i $f --report
            currdir=`dirname $f`; currfile=`basename $f`; currfile="${currfile%%.*}"
            icadir=${currdir}/${currfile}.ica
            outname=${namesansextension}_IC.nii.gz
            cp ${icadir}/melodic_IC.nii.gz $outname
            mv ${icadir} ${currdir}/${currfile}_ICAdir
            # mv ${icadir}/report ${currdir}/${currfile}_IC_reports
            # mv ${icadir}/mean.nii.gz ${icadir}/mask.nii.gz ${currdir}/${currfile}_IC_reports
            # rm -rf $icadir
            ;;
        # stats)
        #     # Stats
        #     fslstats $f
        #     ;;
        testinputs)
            echo ${inputs[@]}
            break
            ;;
        v|view)
            fslview `echo ${inputssansextension[@]}`
            echo ${inputssansextension[@]}
            break
            ;;
        *)
            echo "Operation not implemented yet."
            break
            ;;
    esac

    ((INDEX_AT=INDEX_AT+1))

done

# In case I decide to write something else later..
INDEX_AT=
